# Polymorph-lib

This is a header-only library that provides various functionality for randomization on compile-time, in a convenient to use manner that is easy to integrate.

This is *not* a polymorphic code engine, but it takes inspiration from the concept of polymorphic code. You can, however, simulate a polymorphic code engine by recompiling your program each time you would like to run it.

## Use-cases

* binary fingerprinting -- you could distribute a different but equivalent binary to multiple people, and keep track of who received what binary. If your binary becomes leaked, you can trace the leaker back using the original binary.
* signature evasion -- signatures can be generated by hashing files or memory. Code that involves compile-time randomization can evade signature detection between different compiles
* experimentation -- it can be useful to ensure that different permutations of code are equivalent through random sampling, as can be done with this

## Usage

1. Put `include/polymorph-lib.h` somewhere in your project.
2. Include it to your project through `#include "polymorph-lib.h"` or some related include statement
## Details

Before I describe the details of the random number generator, I should delve into the source of entropy used. The GCC supports `__DATE__` and `__TIME__` macros which change on each compile (assuming the compiles aren't made within the same second). We combine those into an integer, that acts as our initial seed.

We then make use of a counter-based-psuedo-random-number-generator (CBPRNG). Normal PRNGs will use usually use their own output as the state to use for their next calculations. Because we are dealing with compile-time calculations this is easier said than done, and it's easier if our state is an available macro like `__COUNTER__` which will automatically increment each time it is referenced. A good fit for this is the [Widynski's Squares](https://arxiv.org/abs/2004.06278) CBPRNG. Because this is all done as a `constexpr` it can be calculated at compile time.

Now we want to turn these compile-time random variables into different code. We make different branches of code (via `if` or `case` statements) with their conditional based on these random variables, and then rely on compiler optimizations to eliminate unused branches.

It's important to note that using functions this way would only evaluate the branch elimination once, and go with that. This means that any call to `poly_junk()` would produce the same code no matter when or where it was used in the program (though it would change on runtime) even when inlined. We instead use `#define` macros for this purpose, so that the preprocessor replaces `poly_junk()` with the corresponding code, which allows the compiler to evaluate each branch separately and results in different code output each time.